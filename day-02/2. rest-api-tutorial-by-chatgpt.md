
# ⚙️ প্রকল্প স্ট্রাকচার (functional + Laravel-like pattern but simple)

```
mini-php-api/
│
├── app/
│   └── auth.php               <-- login handler (functional)
│
├── core/
│   ├── db.php                 <-- PDO connection function
│   └── jwt.php                <-- JWT encode / decode functions
│
├── config/
│   ├── database.php           <-- DB config (array)
│   └── jwt.php                <-- JWT config (secret, expiry)
│
├── helpers/
│   └── http.php               <-- small HTTP helper functions
│
├── scripts/
│   └── create_user.php        <-- CLI script to add initial user (hashed password)
│
├── routes/
│   └── api.php                <-- route dispatcher
│
├── index.php                  <-- entry point
└── README.md
```

---

# 1) `config/database.php`

```php
<?php
// config/database.php
return [
  'host' => '127.0.0.1',
  'dbname' => 'mini_api',
  'username' => 'root',
  'password' => '',
  'charset' => 'utf8mb4'
];
```

**একদম ভাঙা-ভাঙা ব্যাখ্যা**

* `<?php` — পিএইচপি স্ক্রিপ্ট শুরু। সব PHP ফাইলে লাগে।
* `return [...]` — এই ফাইল `include` করলে এটাকে একটি array হিসেবে পাওয়া যাবে; আমরা কনফিগ হিসেবে ব্যবহার করব।
* `host, dbname, username` ইত্যাদি — ডাটাবেস সংযোগের জন্য প্রয়োজনীয় তথ্য। পরে `core/db.php` এই array নিবে।

---

# 2) `config/jwt.php`

```php
<?php
// config/jwt.php
return [
  'secret' => 'change_this_to_a_strong_random_string_!@#', // production এ .env ব্যবহার করো
  'algo' => 'HS256',
  'expiry' => 3600 // token life in seconds (1 hour)
];
```

**ব্যাখ্যা**

* `secret` — JWT সিগনেচারের জন্য কী। অবশ্যই শক্তিশালী রাখবে; production এ env থেকে নেবে।
* `expiry` — টোকেন কতক্ষণ বৈধ থাকবে (seconds)।

---

# 3) `core/db.php` — PDO সংযোগ (functional)

```php
<?php
// core/db.php
function db_connect() {
  $cfg = include __DIR__ . '/../config/database.php';

  // DSN (Data Source Name) তৈরি
  $dsn = "mysql:host={$cfg['host']};dbname={$cfg['dbname']};charset={$cfg['charset']}";

  $options = [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,        // error হলে Exception ছুঁড়বে
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,   // fetch করলে associative array পাব
    PDO::ATTR_EMULATE_PREPARES => false                 // নেটিভ prepared statements ব্যবহার করবে
  ];

  try {
    return new PDO($dsn, $cfg['username'], $cfg['password'], $options);
  } catch (PDOException $e) {
    // production এ এখানে generic message রাখো, local/development এ $e->getMessage() ব্যবহার করতে পারো
    http_response_code(500);
    echo json_encode(['error' => 'Database connection failed']);
    exit;
  }
}
```

**লাইন-বাই-লাইন ব্যাখ্যা (Atomic):**

1. `function db_connect()` — আমরা একটা function বানাচ্ছি; এটা কল করলে PDO অবজেক্ট রিটার্ন করবে। (ফাংশনাল স্টাইল)
2. `$cfg = include ...` — কনফিগ ফাইল লোড করে $cfg এ রাখলাম (array)।
3. `$dsn = "mysql:host=...";` — PDO কীভাবে DB-তে গেল তা বলে দেয় (host, dbname, charset)।
4. `$options = [...]` — PDO কাজ করার সময় নিরাপত্তা এবং ডিফল্ট আচরণ নির্ধারণ করে।

   * `PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION` — যদি DB error হয়, তাহলে Exception দিবে; এতে try/catch করা যায়।
   * `PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC` — `fetch()` করলে associative array (কী => মান) পাই; numeric index নয়।
   * `PDO::ATTR_EMULATE_PREPARES => false` — সঠিক prepared statements ব্যবহার করে, SQL injection রোধে সহায়তা করে।
5. `new PDO(...)` — আসলেই DB-তে connect করছে।
6. `catch (PDOException $e)` — যদি connection fail করে, আমরা HTTP 500 পাঠিয়ে exit করে দিচ্ছি। (development এ message দেখানো যাবে)

**কেন এভাবে?**

* Prepared statements + no emulation = safer against SQL injection।
* Default fetch associative makes code readable (`$row['email']`)।

---

# 4) `core/jwt.php` — JWT encode / decode (functional, simple, safe)

```php
<?php
// core/jwt.php

function base64url_encode($data) {
  return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');
}

function base64url_decode($data) {
  $remainder = strlen($data) % 4;
  if ($remainder) {
    $padlen = 4 - $remainder;
    $data .= str_repeat('=', $padlen);
  }
  return base64_decode(strtr($data, '-_', '+/'));
}

function jwt_encode(array $payload) {
  $cfg = include __DIR__ . '/../config/jwt.php';
  $header = ['alg' => $cfg['algo'], 'typ' => 'JWT'];

  $payloadEncoded = base64url_encode(json_encode($payload));
  $headerEncoded = base64url_encode(json_encode($header));

  $signature = hash_hmac('sha256', "$headerEncoded.$payloadEncoded", $cfg['secret'], true);
  $signatureEncoded = base64url_encode($signature);

  return "$headerEncoded.$payloadEncoded.$signatureEncoded";
}

function jwt_decode($token) {
  $cfg = include __DIR__ . '/../config/jwt.php';
  $parts = explode('.', $token);

  if (count($parts) !== 3) return false;

  list($headerEncoded, $payloadEncoded, $signatureEncoded) = $parts;

  $signature = base64url_decode($signatureEncoded);
  $expected = hash_hmac('sha256', "$headerEncoded.$payloadEncoded", $cfg['secret'], true);

  // timing-attack safe comparison
  if (!hash_equals($expected, $signature)) return false;

  $payloadJson = base64url_decode($payloadEncoded);
  $payload = json_decode($payloadJson, true);

  if (!$payload) return false;

  // check expiry if present
  if (isset($payload['exp']) && time() > $payload['exp']) return false;

  return $payload;
}
```

**ব্যাখ্যা (atomic):**

* `base64url_encode` / `base64url_decode` — JWT-এ ব্যবহৃত base64url ফরম্যাট; `+ /` কে `- _` দিয়ে replace করে, ও trailing `=` মুছে দেয়। এটা URL-safe।
* `jwt_encode(array $payload)`:

  1. `include config/jwt.php` — secret ও algo নেবে।
  2. `header` — `{ "alg": "HS256", "typ": "JWT" }`।
  3. `json_encode()` → `base64url_encode()` — header ও payload encode করা হচ্ছে।
  4. `hash_hmac('sha256', ...)` — signature তৈরি; শেষ param `true` বলে raw binary return করে, যেটা base64url encode করা হবে।
  5. `return "$header.$payload.$signature"` — JWT স্ট্রিং।
* `jwt_decode($token)`:

  1. `explode('.', $token)` — টোকেনকে তিন ভাগে ভাগ করে।
  2. signature verify — হ্যাশিং করে `hash_equals()` দিয়ে তুলনা (timing-attack safe)।
  3. payload json decode করে array পায়।
  4. `exp` যদি থাকে এবং এক্সপায়ার হয়ে থাকে → return false।
  5. সফল হলে payload array রিটার্ন করবে (উদাহরণ: `['sub'=>1,'email'=>'x@x.com','iat'=>...,'exp'=>...]`)

**কেন এইভাবে?**

* সরল HS256 signature — production এ secret অবশ্যই শক্তিশালী এবং env এ রাখবে।
* আমরা `exp` চেক করছি যাতে token মেয়াদ শেষ হলে refuse করা হয়।

---

# 5) `helpers/http.php` — ছোট HTTP utilities

```php
<?php
// helpers/http.php

function get_json_input() {
  $raw = file_get_contents('php://input');
  $data = json_decode($raw, true);
  return is_array($data) ? $data : [];
}

function send_json($data, $status = 200) {
  http_response_code($status);
  header('Content-Type: application/json; charset=utf-8');
  echo json_encode($data, JSON_UNESCAPED_UNICODE);
  exit;
}

function get_bearer_token() {
  // getallheaders() is more portable, but on some setups you may use $_SERVER['HTTP_AUTHORIZATION']
  $headers = function_exists('getallheaders') ? getallheaders() : [];
  $auth = $headers['Authorization'] ?? $headers['authorization'] ?? ($_SERVER['HTTP_AUTHORIZATION'] ?? null);
  if (!$auth) return null;
  if (stripos($auth, 'Bearer ') === 0) {
    return trim(substr($auth, 7));
  }
  return null;
}

function respond_error($message = 'Error', $code = 400) {
  send_json(['error' => $message], $code);
}
```

**ব্যাখ্যা (atomic):**

* `file_get_contents('php://input')` — HTTP request body র উপাদান নেয় (raw)। POST JSON পাঠালে এখান থেকে JSON পাব।
* `json_decode(..., true)` — JSON → associative array; `true` দিলে array পায়।
* `send_json($data, $status)` — standardized JSON response পাঠায় এবং exit করে যাতে code পরে চলে না।
* `get_bearer_token()` — `Authorization: Bearer <token>` হেডার থেকে token বের করে দেয়।
* `respond_error()` — error message পাঠানোর সহজ wrapper।

---

# 6) `app/auth.php` — Login handler (functional)

```php
<?php
// app/auth.php
require_once __DIR__ . '/../core/db.php';
require_once __DIR__ . '/../core/jwt.php';
require_once __DIR__ . '/../helpers/http.php';

function login_handler() {
  $data = get_json_input();

  $email = isset($data['email']) ? trim($data['email']) : '';
  $password = $data['password'] ?? '';

  if ($email === '' || $password === '') {
    respond_error('Email and password are required', 400);
  }

  $pdo = db_connect();

  // prepared statement ব্যবহার করছি: নিরাপত্তার জন্য
  $stmt = $pdo->prepare('SELECT id, email, password FROM users WHERE email = ? LIMIT 1');
  $stmt->execute([$email]);
  $user = $stmt->fetch(PDO::FETCH_ASSOC);

  if (!$user) {
    respond_error('Invalid credentials', 401);
  }

  // password_verify: hashed password মিলানো
  if (!password_verify($password, $user['password'])) {
    respond_error('Invalid credentials', 401);
  }

  // token payload - 'sub' subject হিসেবে user id রাখা ভালো
  $cfg = include __DIR__ . '/../config/jwt.php';
  $now = time();
  $payload = [
    'sub' => (int)$user['id'],
    'email' => $user['email'],
    'iat' => $now,
    'exp' => $now + $cfg['expiry']
  ];

  $token = jwt_encode($payload);

  send_json(['token' => $token]);
}
```

**Atomic ব্যাখ্যা (প্রত্যেক লাইন):**

1. `require_once ...` — প্রয়োজনীয় ফাইলগুলো লোড করছি (DB, JWT, HTTP helper)। `require_once` যদি ফাইল না থাকে তাহলে fatal error দিবে; একবারই লোড হবে।
2. `function login_handler()` — login করার কাজ এখানে। যেকোন জায়গা থেকে `login_handler()` কল করলে কাজ হবে।
3. `$data = get_json_input();` — request body থেকে JSON read করে array পাই।
4. `$email = isset($data['email']) ? trim($data['email']) : '';` — আছে কিনা চেক করে, আর `trim()` করে whitespace সরাই।
5. `if ($email === '' || $password === '')` — ইনপুট validation; ফাঁকা হলে 400 Bad Request।
6. `$pdo = db_connect();` — PDO connection পেয়ে নিচ্ছি।
7. `$stmt = $pdo->prepare('SELECT ...')` — prepared statement তৈরি (প্রতি ভ্যারিয়েবল আলাদা করে দিতে হবে)।
8. `$stmt->execute([$email]);` — execute করার সময় array দিয়ে param bind করা হলো। এতে SQL injection রোধ হয়।
9. `$user = $stmt->fetch(PDO::FETCH_ASSOC);` — কালে এক রেকর্ড পেলাম (associative array)।
10. `if (!$user)` — ইউজার না থাকলে লগইন না দেয়া।
11. `password_verify($password, $user['password'])` — plain password (user input) কে DB তে রাখা hashed password সঙ্গে মিলায়; এটা নিরাপদ।
12. `$cfg = include ...` — JWT config নিলে expiry ও secret ব্যবহার করব।
13. `iat` ও `exp` — issued at এবং expiry timestamp রাখা (security best-practice)।
14. `$token = jwt_encode($payload);` — JWT তৈরি।
15. `send_json(['token' => $token]);` — successful response পাঠানো (HTTP 200)।

**নোট:** `password_verify` ব্যবহার করার আগে DB-এ password `password_hash()` দিয়ে hashed রাখবে। কখনোই plain text সংরক্ষণ করবে না।

---

# 7) `routes/api.php` — সরল dispatcher

```php
<?php
// routes/api.php
require_once __DIR__ . '/../app/auth.php';
require_once __DIR__ . '/../helpers/http.php';

$uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
$method = $_SERVER['REQUEST_METHOD'];

// normalize trailing slash: '/api/login' and '/api/login/' treated same
$uri = rtrim($uri, '/');

if ($uri === '/api/login' && $method === 'POST') {
  login_handler();
} else {
  respond_error('Route not found', 404);
}
```

**ব্যাখ্যা**

* `parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH)` — request path নিতে ব্যবহৃত।
* `$_SERVER['REQUEST_METHOD']` — GET / POST ইত্যাদি।
* `rtrim($uri,'/')` — শেষে slash থাকলেও একই রুট বানায়।
* যদি `/api/login` POST হয় → `login_handler()` কল করো, নয়তো 404 response।

---

# 8) `index.php` — এন্ট্রি পয়েন্ট

```php
<?php
// index.php
// সব response JSON হবে
header('Content-Type: application/json; charset=utf-8');

require_once __DIR__ . '/routes/api.php';
```

**ব্যাখ্যা**

* `header('Content-Type: application/json')` — ব্রাউজার / Postman কে বলছে response JSON।
* `require_once 'routes/api.php'` — রাউট চালু করে দেয়; routes খুঁজে করে handler-run করে।

---

# 9) DB টেবিল (MySQL) — `users` table

```sql
CREATE TABLE users (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**ব্যাখ্যা**

* `id` — primary key।
* `email` — unique constraint; একই email আবার পাবে না।
* `password` — hashed password (bcrypt via `password_hash()`), তাই VARCHAR(255) রাখা হয়েছে।
* `created_at` — কবে user তৈরি হয়েছে, auto timestamp।

---

# 10) `scripts/create_user.php` — প্রাথমিক User তৈরির জন্য (CLI)

```php
<?php
// scripts/create_user.php
require_once __DIR__ . '/../core/db.php';

$email = $argv[1] ?? null;
$password = $argv[2] ?? null;

if (!$email || !$password) {
  echo "Usage: php create_user.php user@example.com password\n";
  exit(1);
}

$hash = password_hash($password, PASSWORD_DEFAULT);

$pdo = db_connect();
$stmt = $pdo->prepare('INSERT INTO users (email, password) VALUES (?, ?)');
try {
  $stmt->execute([$email, $hash]);
  echo "User created: $email\n";
} catch (PDOException $e) {
  echo "Error: " . $e->getMessage() . "\n";
}
```

**ব্যাখ্যা**

* CLI script: `php scripts/create_user.php user@example.com strongpass`
* `password_hash()` — plain password কে bcrypt (default) এ hash করে; DB-তে এই hashই সেভ হবে।
* Prepared statement দিয়ে insert করা হলো।

---

# 11) Testing (Postman / curl)

**১) Create user (CLI)**

```
php scripts/create_user.php user@example.com 123456
```

(এটি DB তে hashed password ঢুকাবে)

**২) Login request (Postman / curl)**
URL: `http://localhost:8000/api/login`
Method: POST
Body → raw → JSON:

```json
{
  "email": "user@example.com",
  "password": "123456"
}
```

**curl কমান্ড:**

```bash
curl -X POST http://localhost:8000/api/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","password":"123456"}'
```

**Success response**

```json
{
  "token": "eyJhbGciOi..."
}
```

**Failure response (invalid credentials)**

```json
{
  "error": "Invalid credentials"
}
```

---

# 12) সিকিউরিটি নোটস (প্রোডাকশন-রেডি নয় কিন্তু ভালো শুরু)

* **Secret** `.env` থেকে নেবে; ফাইল রেপোজিটরিতে commit করো না।
* HTTPS ব্যবহার করো — token/credentials সবসময় TLS-এর উপর পাঠাও।
* Token revoke বা blacklist দরকার হলে DB/Redis এ সেই লজিক যোগ করতে হবে।
* `expiry` ছোট রাখো (1 hour) এবং refresh token pattern বিবেচনা করো।
* SQL errors কে ইউজারকে সরাসরি দেখিও না (অন্তত production mode এ)।

---

# 13) ছোট-খাটো প্রশ্নের উত্তর (যা তুমি হয়ত ভাবছ)

* **কেন prepared statements?** — SQL injection থেকে বাঁচাতে। `?` placeholder এ ভ্যালু আলাদা পাঠানো হয়, SQL structure আলাদা থাকে।
* **কেন password_hash & password_verify?** — plain password কখনো DB-এ রাখবে না। `password_hash()` bcrypt ব্যবহার করে hash দেয়; `password_verify()` দিয়ে মিলানো হয়।
* **JWT কিভাবে verify হয়?** — header.payload নিয়ে secret দিয়ে HMAC করে signature তুলনা করি। `hash_equals()` ব্যবহার করে timing-attack-safe compare করি।
* **কেন `base64url`?** — JWT URL-safe base64 ব্যবহার করে (+ / → - _)।

---

# 14) এখন কী? (তুমি কী চাও আমি পরের ধাপেই আনব)

* পরের ধাপে আমি একই atomic style-এ তৈরি করব:

  1. `/api/products` (GET) — সকল প্রোডাক্ট আনা (PDO + prepared statement)
  2. `/api/products/{id}` (GET) — এক প্রোডাক্ট ডিটেইল
  3. `/api/checkout` (POST) — Bearer JWT token দিয়ে প্রটেক্ট করা, এবং basic checkout logic
* চাইলে আমি এগুলো একে একে দিই, প্রতিটা ফাইলের প্রতিটি লাইনের ব্যাখ্যা সহ।

---

ভাই, যদি এখনি শুরু করতে চাও — বলো, আমি **Products API**–এর atomic টিউটোরিয়াল শুরু করছি (ফাংশনাল স্টাইল)। অথবা তুমি চাইলে এই Login কোড তোমার লোকাল সার্ভারে রান করো — কোন জায়গায় error দেখলে এখানে paste করো, আমি step-by-step debug বলব।
